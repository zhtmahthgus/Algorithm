//힙 삭제(removeMin)
->루트키를 삭제
1. 루트 키를 마지막 노드 키로 대체
2. 마지막 노드와 그의 자식들을 외부노드로 축소(reduceExternal)
3. 힙순서 재정렬(downHeap)
void downHeap(HeapType *h)
{
    int temp = h->heap[1];
    int parent = 1, child = 2;
    while(child <= h->heap_size)
    {
        if(child < h->heap_size && h->heap[child] > h->heap[child + 1])//오른쪽 자식 노드가 있을 때
            child++;
        if(temp <= h->heap[child])
            break;
        h->heap[parent] = h->heap[child];
        parent = child;
        child *= 2;
    }
    h->heap[parent] = temp;
}
int removeMin(HeapType *h)
{
    int key = h->heap[1];
    h->heap[1] = h->heap[h->heap_size];
    h->heap_size -= 1;
    downHeap(h);
    return key;
}
//힙 정렬(heap sort)
void heapSort(HeapType *h, int list[])
{
    HeapType heap;
    init(&heap);
    for(int i = 1; i <= h->heap_size; i++)
    {
        heap.heap[i] = h->heap[i];//포인터가 아니므로 도트 연산자 접근
        heap.heap_size++;
    }
    for(int i = 1; i<= h->heap_size; i++)
        list[i] = removeMin(&heap);
}
void printArray(int list[], int n)
{
    for(int i = 1; i <= n; i++)
        printf("[%d] ", list[i]);
    printf("\n");
}
int main()
{
    HeapType heap;
    int list[MAX_ELEMENT] = {0};
    init(&heap);
    insertItem(&heap, 5);
    insertItem(&heap, 3);
    insertItem(&heap, 7);
    insertItem(&heap, 4);
    insertItem(&heap, 1);
    insertItem(&heap, 4);
    insertItem(&heap, 8);
    insertItem(&heap, 2);
    printHeap(&heap);
    printf("deleted key: %d\n", removeMin(&heap));
    printHeap(&heap);
    heapSort(&heap, list);
    printArray(list, heap.heap_size);
    printHeap(&heap);
}
//힙의 마지막 노드
#include <stdio.h> 
#include <stdlib.h> 
#define MAX_ELEMENT 100

typedef struct {
	int data[MAX_ELEMENT];
	int top;
} StackType;

typedef struct
{
    int heap[MAX_ELEMENT];
    int heap_size;
}HeapType;
//Stack
void init_Stack(StackType *s)
{
	s->top = -1;
}

int is_Empty(StackType *s)
{
	return (s->top == -1);
}

void push(StackType *s, int item)
{
    s->data[++(s->top)] = item;
}

int pop(StackType *s)
{
	if (is_Empty(s)) {
		exit(1);
	}
	else return s->data[(s->top)--];
}
//Heap
void init_Heap(HeapType *h)
{
    h->heap_size = 0;
}

void upHeap(HeapType *h)
{
    int i = h->heap_size;
    int key = h->heap[i];
    while(i != 1 && key < h->heap[i/2])
    {
        h->heap[i] = h->heap[i/2];
        i /= 2;
    }
    h->heap[i] = key;
}

void insertItem(HeapType *h, int key)
{
    h->heap_size += 1;
    h->heap[h->heap_size] = key;
    upHeap(h);
}

void binaryExpansion(StackType *s, int i)
{
    while(i>=2)
    {
        push(s, i%2);
        i /= 2;
    }
    push(s, i);
}

int findLastNode(HeapType *h, int n)
{
    StackType s;
	init_Stack(&s);
	binaryExpansion(&s, n);
	pop(&s);
	int bit = 0;
	int i = 1;
	int v = h->heap[i];
	while(!is_Empty(&s))
	{
	    bit = pop(&s);
	    if(bit == 0)
	    {
	        v = h->heap[i*2];
	        i = i*2;
	    }
	    else
	    {
	        v = h->heap[i*2 + 1];
	        i = i*2 + 1;
	    }
	            
	}
	return v;
}

void printHeap(HeapType *h)
{
    for(int i = 1; i <= h->heap_size; i++)
        printf("[%d] ", h->heap[i]);
    printf("\n");
}

int main(void)
{
    HeapType h;
    init_Heap(&h);
    insertItem(&h, 2);
    insertItem(&h, 6);
    insertItem(&h, 4);
    insertItem(&h, 14);
    insertItem(&h, 7);
    insertItem(&h, 12);
    insertItem(&h, 8);
    insertItem(&h, 17);
    insertItem(&h, 15);
    insertItem(&h, 9);
    printHeap(&h);
    printf("%d", findLastNode(&h, 10));
}
